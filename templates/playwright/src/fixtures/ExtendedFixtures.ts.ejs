import { checkoutData } from '@data';
import { Fixtures } from '@fixtures';
import { CartPage, CheckoutPage, HomePage, InventoryPage, LoginPage } from '@pages';
import { test as baseTest } from '@playwright/test';
import { ARTIFACTS_DIR, loadSessionCookies, logger } from '@utils';
import path from 'path';

const COOKIES_DIR = path.join(ARTIFACTS_DIR, 'cookies');

// Keep your existing env naming
const storageStatePath = path.resolve(COOKIES_DIR, `${process.env.USERNAME}_cookies.json`);

// ---- Auth mode switch (FORM | SESSION | COOKIES) ----
type AuthMode = 'FORM' | 'SESSION' | 'COOKIES';
const AUTH_MODE = (process.env.AUTH_MODE?.toUpperCase() as AuthMode) || 'FORM';

export const test = baseTest.extend<Fixtures>({
  /**
   * A single "authedPage" that guarantees the built-in `page` is authenticated
   * regardless of the chosen AUTH_MODE. All POs are built on top of this.
   */
  authedPage: async ({ page }, use) => {
    if (AUTH_MODE === 'SESSION') {
      // Already authed via storageState
      await use(page);
      return;
    }

    if (AUTH_MODE === 'COOKIES') {
      // Inject cookies into current page (your helper)
      await loadSessionCookies(page, storageStatePath);
      // Hit the app so cookies apply to the domain (baseURL recommended in config)
      await page.goto('/');
      await use(page);
      return;
    }

    logger.info(`AUTH MODE: ${AUTH_MODE}`);
    // Default: FORM login on the same built-in page
    const loginPage = new LoginPage(page);
    await loginPage.navigation.goToLoginPage();
    await loginPage.login(process.env.USERNAME!, process.env.USERPASSWORD!);
    await use(page);
  },

  // Page Objects built on the single authenticated page
  homePage: async ({ authedPage }, use) => {
    await use(new HomePage(authedPage));
  },

  inventoryPage: async ({ authedPage }, use) => {
    await use(new InventoryPage(authedPage));
  },

  cartPage: async ({ authedPage }, use) => {
    await use(new CartPage(authedPage));
  },

  checkoutPage: async ({ authedPage }, use) => {
    await use(new CheckoutPage(authedPage));
  },

  /**
   * Checkout test data fixture
   * - Loads from ./data/checkout.ts (typed import)
   * - Available as `{ checkoutData }` in all tests
   */
  checkoutData: async ({}, use) => {
    await use(checkoutData);
  },
});

// If SESSION, attach storageState at context creation (most reliable)
// do auth-mode tweaks AFTER defining `test`
if ((process.env.AUTH_MODE ?? 'FORM').toUpperCase() === 'SESSION') {
  test.use({ storageState: storageStatePath });
}

export const expect = test.expect;
