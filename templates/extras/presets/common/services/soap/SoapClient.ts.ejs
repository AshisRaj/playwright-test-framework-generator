import { APIRequestContext, request, type TestInfo } from '@playwright/test';
import { parseSoapResponse } from '@services';
import { allure } from 'allure-playwright';

export interface SoapOptions {
  url?: string;
  headers?: Record<string, string>;
  soapAction?: string;
  body?: string;
  responsePath?: string; // JSON path to extract result
  log?: boolean;
}

export class SoapClient {
  private request!: APIRequestContext;
  private options: SoapOptions;
  private testInfo: TestInfo;

  constructor(options: SoapOptions, testInfo: TestInfo) {
    this.options = options;
    this.testInfo = testInfo;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async call<T = any>(
    options?: SoapOptions,
  ): Promise<{
    status: number;
    rawBody: string;
    parsed?: T;
  }> {
    this.request = await request.newContext();

    const url = this.options.url || options?.url;
    if (!url) {
      throw new Error('A valid URL must be provided for the SOAP request.');
    }

    const headers = options?.headers ?? this.options.headers;
    const data = options?.body ?? this.options.body;

    const reqPayload = {
      method: 'POST',
      url,
      headers: headers,
      body: data,
    };
    await allure.attachment(
      `REQUEST: POST ${url} ${headers ? JSON.stringify(headers) : ''}`,
      JSON.stringify(reqPayload, null, 2),
      'application/json',
    );

    const response = await this.request.post(url, {
      headers: headers,
      data: data,
    });
    const responseText = await response.text();

    const respPayload = {
      status: response.status(),
      statusText: response.statusText(),
      headers: response.headers(),
      body: responseText,
    };
    await allure.attachment(
      `RESPONSE: ${response.status()} ${response.statusText()}`,
      JSON.stringify(respPayload, null, 2),
      'application/json',
    );

    return {
      status: response.status(),
      rawBody: responseText,
      parsed:
        response.status() < 500
          ? parseSoapResponse<T>(
              responseText,
              options?.responsePath ??
                this.options.responsePath ??
                (() => {
                  throw new Error('A valid responsePath must be provided.');
                })(),
            )
          : undefined,
    };
  }

  async dispose() {
    await this.request.dispose();
  }
}
