import { APIRequestContext, APIResponse, request as baseRequest, TestInfo } from '@playwright/test';
import { logger } from '@utils';
<% if (reporter !== 'monocart') { %>
import { allure } from 'allure-playwright';
<% } %>

type ClientCertificate = {
  origin: string;
  certPath?: string;
  keyPath?: string;
  pfxPath?: string;
  passphrase?: string;
};

export type ApiOptions = {
  apiBaseURL?: string;
  apiEndPoint?: string;
  extraHTTPHeaders?: Record<string, string>;
  headers?: Record<string, string>;
  clientCertificates?: ClientCertificate[];
  log?: boolean;
  retryCount?: number; // Number of retries for failed requests
  retryDelayMs?: number; // Delay between retries in ms
  polling?: boolean; // Enable polling
  pollingIntervalMs?: number; // Polling interval in ms
  pollingTimeoutMs?: number; // Max time to poll in ms
};

export class ApiClient {
  private request;
  private headers?: Record<string, string>;
  private testInfo: TestInfo;
  private log: boolean;
  private retryCount: number;
  private retryDelayMs: number;
  private polling: boolean;
  private pollingIntervalMs: number;
  private pollingTimeoutMs: number;

  constructor(
    {
      apiBaseURL,
      apiEndPoint,
      extraHTTPHeaders,
      headers,
      clientCertificates,
      log,
      retryCount = 0,
      retryDelayMs = 500,
      polling = false,
      pollingIntervalMs = 1000,
      pollingTimeoutMs = 10000,
    }: ApiOptions,
    testInfo: TestInfo,
  ) {
    // newContext returns a Promise<APIRequestContext> so keep the promise here
    this.request = baseRequest.newContext({
      baseURL: apiEndPoint ? `${apiBaseURL}/${apiEndPoint}/` : apiBaseURL,
      extraHTTPHeaders: extraHTTPHeaders,
      clientCertificates: clientCertificates,
      ignoreHTTPSErrors: false,
    }) as Promise<APIRequestContext>;
    this.headers = headers;
    this.testInfo = testInfo;
    this.log = log || false;
    this.retryCount = retryCount;
    this.retryDelayMs = retryDelayMs;
    this.polling = polling;
    this.pollingIntervalMs = pollingIntervalMs;
    this.pollingTimeoutMs = pollingTimeoutMs;
  }

  async get(url: string, options?: ApiOptions) {
    return this.execute('GET', url, undefined, options);
  }

  async post(url: string, body?: unknown, options?: ApiOptions) {
    return this.execute('POST', url, body, options);
  }

  async put(url: string, body?: unknown, options?: ApiOptions) {
    return this.execute('PUT', url, body, options);
  }

  async patch(url: string, body?: unknown, options?: ApiOptions) {
    return this.execute('PATCH', url, body, options);
  }

  async delete(url: string, options?: ApiOptions) {
    return this.execute('DELETE', url, undefined, options);
  }

  private async execute(
    method: string,
    url: string,
    body?: unknown,
    options?: ApiOptions,
  ): Promise<APIResponse> {
    // Merge options: instance defaults overridden by per-request options
    const retryCount = options?.retryCount ?? this.retryCount;
    const retryDelayMs = options?.retryDelayMs ?? this.retryDelayMs;
    const polling = options?.polling ?? this.polling;
    const pollingIntervalMs = options?.pollingIntervalMs ?? this.pollingIntervalMs;
    const pollingTimeoutMs = options?.pollingTimeoutMs ?? this.pollingTimeoutMs;
    const headers = options?.headers ?? this.headers;
    const ctx = await this.request;
    let attempts = 0;
    let lastError: unknown = null;

    // Helper for delay
    const delay = (ms: number) => new Promise((res) => setTimeout(res, ms));

    // Retry logic
    logger.info(
      `API Request: ${method} ${url} | Retry: ${retryCount} | Polling: ${polling} | Timeout: ${pollingTimeoutMs}ms | Interval: ${pollingIntervalMs}ms`,
    );

    <% if (reporter !== 'monocart') { %>
    const reqPayload = {
      method,
      url,
      headers,
      body,
      retrySettings: {
        retryCount: retryCount,
        retryDelayMs: retryDelayMs,
        polling: polling,
        pollingIntervalMs: pollingIntervalMs,
        pollingTimeoutMs: pollingTimeoutMs,
      },
    };
    await allure.attachment(
      `REQUEST: ${method} ${url}`,
      JSON.stringify(reqPayload, null, 2),
      'application/json',
    );
    <% } %>

    while (attempts <= retryCount) {
      try {
        if (polling) {
          // Polling logic
          const start = Date.now();
          while (Date.now() - start < pollingTimeoutMs) {
            const response = await ctx.fetch(url, {
              method,
              data: body,
              headers,
            });
            if (response.ok()) {
              return response;
            }
            await delay(pollingIntervalMs);
          }
          throw new Error(`Polling timed out after ${pollingTimeoutMs}ms`);
        } else {
          // Standard request with retry
          const response = await ctx.fetch(url, {
            method,
            data: body,
            headers,
          });
          if (response.ok()) {
            <% if (reporter !== 'monocart') { %>
              const respPayload = {
              status: response.status(),
              statusText: response.statusText(),
              headers: response.headers(),
              body: await response.text(),
            };


            await allure.attachment(
              `RESPONSE: ${method} ${url}`,
              JSON.stringify(respPayload, null, 2),
              'application/json',
            );
            <% } %>
            return response;
          } else {
            lastError = new Error(`HTTP error: ${response.status()}`);
          }
        }
      } catch (err) {
        lastError = err;
      }
      attempts++;
      if (attempts <= retryCount) {
        await delay(retryDelayMs);
      }
    }
    throw lastError || new Error('API request failed');
  }

  async dispose() {
    const ctx = await this.request;
    await ctx
      .dispose()
      .then(() => {
        if (this.log) {
          logger.info(`API request context disposed for test: ${this.testInfo.title}`);
        }
      })
      .catch((error) => {
        logger.error(
          `Failed to dispose API request context for test: ${this.testInfo.title}`,
          error,
        );
      });
  }
}
