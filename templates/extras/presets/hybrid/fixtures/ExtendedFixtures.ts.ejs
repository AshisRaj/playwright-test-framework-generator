import {
  calculatorSoapData,
  checkoutData,
  contactsData,
  countryInfoSoapData,
  numberConversionSoapData,
  profilesData,
  usersData,
} from '@data';
import { Fixtures } from '@fixtures';
import { CartPage, CheckoutPage, HomePage, InventoryPage, LoginPage } from '@pages';
import type { Page, TestInfo } from '@playwright/test';
import { expect as baseExpect, test as baseTest } from '@playwright/test';
import { ApiClient, SoapClient, type ApiOptions, type SoapOptions } from '@services';
import { ARTIFACTS_DIR <% if (preset !== 'hybrid' ) { %>, logger<% } %> } from '@utils';
import path from 'path';

const COOKIES_DIR = path.join(ARTIFACTS_DIR, 'cookies');

// ---- Auth mode switch (FORM | SESSION) ----
type AuthMode = 'FORM' | 'SESSION';

export const test = baseTest.extend<Fixtures>({
  // Allow tests to optionally provide API client options via `test.use({ apiServiceOptions: { ... } })`
  apiServiceOptions: async ({}, use: (opts: ApiOptions) => Promise<void>) => {
    await use({});
  },

  // Allow tests to optionally provide SOAP client options via `test.use({ soapServiceOptions: { ... } })`
  soapServiceOptions: async ({}, use: (opts: SoapOptions) => Promise<void>) => {
    await use({});
  },

  // Provide ApiClient wrapper as a fixture that tests can use directly
  apiService: async (
    { apiServiceOptions }: { apiServiceOptions: ApiOptions },
    use: (client: ApiClient) => Promise<void>,
    testInfo: TestInfo,
  ) => {
    const baseURL = apiServiceOptions?.apiBaseURL || process.env.API_BASE_URL;
    const options: ApiOptions = {
      apiBaseURL: baseURL,
      apiEndPoint: apiServiceOptions?.apiEndPoint || '',
      apiHeaders: apiServiceOptions?.apiHeaders,
      clientCertificates: apiServiceOptions?.clientCertificates,
      log: apiServiceOptions?.log,
    };
    const client = new ApiClient(options, testInfo);
    await use(client);
    await client.dispose();
  },

  // Provide SoapClient wrapper as a fixture that tests can use directly
  soapService: async (
    { soapServiceOptions }: { soapServiceOptions: SoapOptions },
    use: (client: SoapClient) => Promise<void>,
    testInfo: TestInfo,
  ) => {
    const wsdlURL = soapServiceOptions?.url;
    const options: SoapOptions = {
      url: wsdlURL,
      headers: soapServiceOptions?.headers,
      soapAction: soapServiceOptions?.soapAction,
      body: soapServiceOptions?.body,
      responsePath: soapServiceOptions?.responsePath,
      log: soapServiceOptions?.log,
    };
    const client = new SoapClient(options, testInfo);
    await use(client);
    await client.dispose();
  },

  /**
  * SOAP test data fixture
  * - Loads from ./data/soap/*.ts (typed import)
  * - Available as `{ soapData }` in all tests
  */
  soapData: async ({}, use) => {
    await use({
      calculator: calculatorSoapData,
      countryInfo: countryInfoSoapData,
      numberConversion: numberConversionSoapData,
    });
  },

  /**
   * API test data fixture
   * - Loads from ./data/api/*.ts (typed import)
   * - Available as `{ apiData }` in all tests
   */
  apiData: async ({}, use) => {
    await use({
      contacts: contactsData,
      users: usersData,
      profiles: profilesData,
    });
  },

  // Authenticated
  page: async ({ browser }, use) => {
    const AUTH_MODE = (process.env.AUTH_MODE?.toUpperCase() as AuthMode) || 'FORM';

    // SESSION — reuse saved storageState (cookies, localStorage)
    if (AUTH_MODE === 'SESSION') {
      const storageStatePath = path.resolve(COOKIES_DIR, `${process.env.USERNAME}_cookies.json`);
      const context = await browser.newContext({ storageState: storageStatePath });
      const page = await context.newPage();
      await use(page);
      await page.close();
      await context.close();
    }

    // FORM (default) — regular fresh page
    if (AUTH_MODE === 'FORM') {
      const context = await browser.newContext();
      const page = await context.newPage();
      const loginPage = new LoginPage(page);
      await loginPage.navigation.goToLoginPage();
      await loginPage.login(process.env.USERNAME!, process.env.USERPASSWORD!);
      await use(page);
      await page.close();
      await context.close();
    }
  },

  // authedPage simply proxies to the `page` fixture so existing POs work
  authedPage: async ({ page }, use) => {
    await use(page);
  },

  // Page Objects built on the single authenticated page
  homePage: async ({ authedPage }, use) => {
    await use(new HomePage(authedPage));
  },

  inventoryPage: async ({ authedPage }, use) => {
    await use(new InventoryPage(authedPage));
  },

  cartPage: async ({ authedPage }, use) => {
    await use(new CartPage(authedPage));
  },

  checkoutPage: async ({ authedPage }, use) => {
    await use(new CheckoutPage(authedPage));
  },

  /**
   * Checkout test data fixture
   * - Loads from ./data/checkout.ts (typed import)
   * - Available as `{ checkoutData }` in all tests
   */
  checkoutData: async ({}, use) => {
    await use(checkoutData);
  },

  // Page objects as fixtures
  loginPage: async ({ page }: { page: Page }, use: (p: LoginPage) => Promise<void>) => {
    const login = new LoginPage(page);
    // Do not perform navigation or automatic login at fixture setup — tests can call these explicitly.
    await use(login);
  },
});

export const expect = baseExpect;
